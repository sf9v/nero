package gen

import (
	"bytes"
	"html/template"

	"github.com/sf9v/nero/comparison"
	gen "github.com/sf9v/nero/gen/internal"
)

func newPredicatesFile(schema *gen.Schema) (*bytes.Buffer, error) {
	buf := new(bytes.Buffer)
	v := struct {
		Ops    []comparison.Operator
		Schema *gen.Schema
	}{
		Ops: []comparison.Operator{
			comparison.Eq,
			comparison.NotEq,
			comparison.Gt,
			comparison.GtOrEq,
			comparison.Lt,
			comparison.LtOrEq,
			comparison.IsNull,
			comparison.IsNotNull,
			comparison.In,
			comparison.NotIn,
		},
		Schema: schema,
	}

	tmpl, err := template.New("predicates.tmpl").Funcs(template.FuncMap{
		"isNullOrNotOp": func(op comparison.Operator) bool {
			return op == comparison.IsNull ||
				op == comparison.IsNotNull
		},
		"isInOrNotOp": func(op comparison.Operator) bool {
			return op == comparison.In ||
				op == comparison.NotIn
		},
	}).Parse(predicatesTmpl)
	if err != nil {
		return nil, err
	}

	err = tmpl.Execute(buf, v)
	if err != nil {
		return nil, err
	}

	return buf, nil
}

const predicatesTmpl = `
// Code generated by nero, DO NOT EDIT.
package {{.Schema.Pkg}}

import (
	"github.com/lib/pq"
	"github.com/sf9v/nero/comparison"
	{{range $import := .Schema.SchemaImports -}}
		"{{$import}}"
	{{end -}}
	{{range $import := .Schema.ColumnImports -}}
		"{{$import}}"
	{{end -}}
)

// PredFunc is a predicate function
type PredFunc func(*comparison.Predicates) 

{{range $col := .Schema.Cols -}}
	{{if $col.HasPreds -}}
		{{range $op := $.Ops -}}
			{{if isNullOrNotOp $op }}
				{{if $col.IsNullable}}
					// {{$col.Field}}{{$op.String}} is a "{{$op.Desc}}" operator on "{{$col.Name}}" column
					func {{$col.Field}}{{$op.String}} () PredFunc {
						return func(pb *comparison.Predicates) {
							pb.Add(&comparison.Predicate{
								Col: "{{$col.Name}}",
								Op: comparison.{{$op.String}},
							})
						}
					}
				{{end}}
			{{else if isInOrNotOp $op }}
				// {{$col.Field}}{{$op.String}} is a "{{$op.Desc}}" operator on "{{$col.Name}}" column
				func {{$col.Field}}{{$op.String}} ({{$col.IdentifierPlural}} {{printf "...%T" $col.Type.V}}) PredFunc {
					args := []interface{}{}
					for _, v := range {{$col.IdentifierPlural}} {
						args = append(args, v)
					}

					return func(pb *comparison.Predicates) {
						pb.Add(&comparison.Predicate{
							Col: "{{$col.Name}}",
							Op: comparison.{{$op.String}},
							Arg: args,
						})
					}
				}
			{{else}}
				// {{$col.Field}}{{$op.String}} is a "{{$op.Desc}}" operator on "{{$col.Name}}" column
				func {{$col.Field}}{{$op.String}} ({{$col.Identifier}} {{printf "%T" $col.Type.V}}) PredFunc {
					return func(pb *comparison.Predicates) {
						pb.Add(&comparison.Predicate{
							Col: "{{$col.Name}}",
							Op: comparison.{{$op.String}},
							{{if and ($col.IsArray) (ne $col.IsValueScanner true) -}}
								Arg: pq.Array({{$col.Identifier}}),
							{{else -}}
								Arg: {{$col.Identifier}},
							{{end -}}
						})
					}
				}

				{{if $col.ColumnComparable -}}
					// {{$col.Field}}{{$op.String}} is a "{{$op.Desc}}" operator on "{{$col.Name}}" column
					func {{$col.Field}}{{$op.String}}Col (col Column) PredFunc {
						return func(pb *comparison.Predicates) {
							pb.Add(&comparison.Predicate{
								Col: "{{$col.Name}}",
								Op: comparison.{{$op.String}},
								Arg: col,
							})
						}
					}
				{{end}}
			{{end}}
		{{end -}}
	{{end}}
{{end -}}
`
