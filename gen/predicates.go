package gen

import (
	"bytes"
	"text/template"

	"github.com/sf9v/nero"
	"github.com/sf9v/nero/comparison"
)

func newPredicatesFile(schema *nero.Schema) (*bytes.Buffer, error) {
	buf := new(bytes.Buffer)
	v := struct {
		Ops    []comparison.Operator
		Schema *nero.Schema
	}{
		Ops: []comparison.Operator{
			comparison.Eq,
			comparison.NotEq,
			comparison.Gt,
			comparison.GtOrEq,
			comparison.Lt,
			comparison.LtOrEq,
			comparison.IsNull,
			comparison.IsNotNull,
			comparison.In,
			comparison.NotIn,
		},
		Schema: schema,
	}

	tmpl, err := template.New("predicates.tmpl").
		Funcs(nero.NewFuncMap()).Parse(predicatesTmpl)
	if err != nil {
		return nil, err
	}

	err = tmpl.Execute(buf, v)
	if err != nil {
		return nil, err
	}

	return buf, nil
}

const predicatesTmpl = `
// Code generated by nero, DO NOT EDIT.
package {{.Schema.PkgName}}

import (
	"github.com/lib/pq"
	"github.com/sf9v/nero/comparison"
	{{range $import := .Schema.Imports -}}
		"{{$import}}"
	{{end -}}
)

// PredFunc is a predicate function
type PredFunc func(*comparison.Predicates) 

{{ $cols := prependToColumns .Schema.Identity .Schema.Columns }}

{{range $col := $cols -}}
	{{if $col.CanHavePreds -}}
		{{range $op := $.Ops -}}
			{{if isNullOp $op }}
				{{if $col.IsNillable}}
					// {{$col.FieldName}}{{$op.String}} applies "{{$op.Desc}}" operator on "{{$col.Name}}" column
					func {{$col.FieldName}}{{$op.String}} () PredFunc {
						return func(pb *comparison.Predicates) {
							pb.Add(&comparison.Predicate{
								Col: "{{$col.Name}}",
								Op: comparison.{{$op.String}},
							})
						}
					}
				{{end}}
			{{else if isInOp $op }}
				// {{$col.FieldName}}{{$op.String}} applies "{{$op.Desc}}" operator on "{{$col.Name}}" column
				func {{$col.FieldName}}{{$op.String}} ({{$col.IdentifierPlural}} {{printf "...%T" $col.TypeInfo.V}}) PredFunc {
					args := []interface{}{}
					for _, v := range {{$col.IdentifierPlural}} {
						args = append(args, v)
					}

					return func(pb *comparison.Predicates) {
						pb.Add(&comparison.Predicate{
							Col: "{{$col.Name}}",
							Op: comparison.{{$op.String}},
							Arg: args,
						})
					}
				}
			{{else}}
				// {{$col.FieldName}}{{$op.String}} applies "{{$op.Desc}}" operator on "{{$col.Name}}" column
				func {{$col.FieldName}}{{$op.String}} ({{$col.Identifier}} {{printf "%T" $col.TypeInfo.V}}) PredFunc {
					return func(pb *comparison.Predicates) {
						pb.Add(&comparison.Predicate{
							Col: "{{$col.Name}}",
							Op: comparison.{{$op.String}},
							{{if and ($col.IsArray) (ne $col.IsValueScanner true) -}}
								Arg: pq.Array({{$col.Identifier}}),
							{{else -}}
								Arg: {{$col.Identifier}},
							{{end -}}
						})
					}
				}

				{{if $col.IsComparable -}}
					// {{$col.FieldName}}{{$op.String}} applies "{{$op.Desc}}" operator on "{{$col.Name}}" column
					func {{$col.FieldName}}{{$op.String}}Col (col Column) PredFunc {
						return func(pb *comparison.Predicates) {
							pb.Add(&comparison.Predicate{
								Col: "{{$col.Name}}",
								Op: comparison.{{$op.String}},
								Arg: col,
							})
						}
					}
				{{end}}
			{{end}}
		{{end -}}
	{{end}}
{{end -}}
`
